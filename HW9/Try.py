### break, continue, pass

# 1) Есть список list1 = [i for i in range(100)], создайте новый список с пробросом каждого пятого элемента
# (используйте continue)

# 2) Напишите скрипт который будет работать циклично в интерактивном режиме, скрипт должен запрашивать
# имя пользователя, если пользователь не вводя имя нажмет на Enter то скрипт должен завершиться (используйте break)

# 3) Есть список: list1 = [‘micros’, ‘python’, ‘linux’, ‘windows’, ‘bobo’], из него составить новый список,
# но без буквы ‘i’, результат: list2 = [‘mcros’, ‘python’, ‘lnux’, ‘wndows’, ‘bobo’] (используйте pass)

### Try/except/finally/else

# 1) Напишите программу, которая запрашивает ввод двух значений. Если хотя бы одно из них не является числом,
# то должна выполняться конкатенация, то есть соединение, строк. В остальных случаях введенные числа суммируются.
# Примеры выполнения программы:
# Первое значение: 4
# Второе значение: 5
# Результат: 9.0
# Первое значение: a
# Второе значение: 9
# Результат: a9

# 2) Есть список: list1 = [1, ‘a’, 3, ‘b’, 5, ‘6’, 7, ‘8’, 9, ‘c’], необходимо разделить на два списка, в первом только цифровые значения, а во втором только строки

# 3) Тот же самый пример, с сообщением после каждой итерации о том что элемент N добавлен

# 4) Приведенный ниже код назначает 5-ю букву каждого слова в food новый список fifth. Однако код в настоящее время выдает ошибки. Вставьте предложение try/except, которое позволит запустить код и создать список 5-й буквы в каждом слове. Если слово недостаточно длинное, оно не должно ничего выводить. Примечание. pass — Оператор является нулевой операцией; ничего не произойдет при его выполнении.

# food = ["chocolate", "chicken", "corn", "sandwich", "soup", "potatoes", "beef", "lox", “lemonade"]
# fifth = []
# for x in food:
# fifth.append(x[4])
# 5) Приведенный ниже код делит значения элемента на самого себя, но вылетает с ошибками, необходимо учесть
# все типы ошибок и дописать код (условия цикла менять нельзя, использовать полный синтаксис try/except/else)
# my_list = [2, "C", 10, "20", "micros", 50, 0, '0', '30']
# for index in range(len(my_list)+5):
#    print(my_list[index] / my_list[index])

# 6) Дописать код (нельзя использовать просто except)

# my_dict ={"key1":"value1","key2":"value2","key3":"value3"}
# search_key = "non-existent key"
# print(my_dict[search_key])

# 7) Замените первый if на try/except/else

# import sys

# if len(sys.argv) < 2:
#        print("Вы не указали название города")
#        print("Try again")
#        exit()

# city = sys.argv[1]
# city = city.lower()


# if city == "tashkent"[0:len(city)]:
#        print ("В Ташкенте тепло и солнечно")
# elif city == "london"[0:len(city)]:
#         print ("В Лондоне пасмурно и сыро")
# elif city == "moskow"[0:len(city)]:
#         print ("В Москве идёт сильный дождь")
# elif city == "paris"[0:len(city)]:
#         print ("погода для романтики")
# elif city == "rio de janeyro"[0:len(city)]:
#         print ("В Рио постоянно карнавалы")

# else:
#         print ("прогноз не ясен, карантин")
# 8) Следующий код работает отлично, если пользователь вводит цифровое значение, но всегда есть НО:
# min = int(input("Введите первое число: "))
# max = int(input("Введите второе число: "))
# for i in range(min, max+1):
#    print(f"Квадрат числа {i} равен {i*i}")

# 9) Ловить ошибки это конечно здорово, но уметь логировать их и записывать в файл еще лучше, задача разобраться со
# стандартной библиотекой logging

# import logging # Загрузка библиотеки

# logging.basicConfig(filename='my_error.log') # Файл появится в том каталоге где запущен скрипт
# logger = logging
# try:
#     1/0
# except ZeroDivisionError as error:
#     logger.error(error)
# Результатом будет запись:
# ERROR:root:division by zero
# a) Найдите способ чтоб можно было добавить время ошибки, например вот так:
# 2022-10-06 11:03:31,466 ERROR  division by zero
# b) Ко всем предыдущим примерам добавить логирования в файл
